def I(x)
  return x

def K(x, y)
  return x

def S(x, y, z)
  return x(z, y(z))



List of functions (where x & y can be any function):
I
K
K[x]
S
S[x]
S[x,y]

Given F and G are functions
And F has arity n
And n > 1
When (F G) appears in the parse tree
Then it is replaced by a function F[G]
And F[G] has arity n-1

Given F and G are functions
And F has arity 1
When (F G) appears in the parse tree
Then (F G) is evaluated


A slalfunc is represented by a struct with the following data:
- a pointer to a function definition (*f)
- a string name (n)
- an integer arity (a)
- a list of length a of pointers to slalfuncs (args)

Example:

F = slalfunc(*f, 'F', 2, [NULL, NULL])
G = slalfunc(*g, 'G', ...)
H = slalfunc(*h, 'H', ...)
J = slalfunc(*j, 'J', ...)

def slalfunc f(slalfunc a, slalfunc b) {
  ...
  return slalfunc(*k, 'K', 3, [NULL, NULL, NULL])
}

The compiler is asked to evaluate F G H J
F G H J -> (((F G) H) J)
(F G) evaluates to Tmp1 = slalfunc(*f, 'F', 2, [*G, NULL])
Since Tmp1.args is not full, it is not evaluated further
F G H J -> ((Tmp1 H) J)
(Tmp1 H) evaluates to Tmp2 = slalfunc(*f, 'F', 2, [*G, *H])
Since Tmp2.args is full, it is passed to Tmp2.*f
Tmp2 = f(G, H) = K
F G H J -> (K J)
(K J) evaluates to Tmp3 = slalfunc(*k, 'K', 3, [*J, NULL, NULL])
F G H J -> Tmp3
Tmp3 is the only function left. A string representation is returned

def string toString(slalfunc a) {
  return '(' + a.name + ' ' + a.args.map(:name).join(' ') + ')'
}

toString(Tmp3) = "(K J)"

Final Result:
>> F G H J
(K J)


Open questions:
How to represent a variable size array?
How to represent a string?

I       \x.x

`KI     \x.I

`K`KI   \x.`KI
``SII   \x.`xx

`K`K`KI \x.`K`KI
`K``SII \x.``SII
``S`KII \x.x
``SI`KI \x.`xI