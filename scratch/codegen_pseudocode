struct slalfunc {
  function* func,
  string name,
  int arity,
  vector<slalfunc*> args
}

def slalfunc* apply(slalfunc* a, slalfunc* i) {
  a.args.push(i)
  if (a.func == 0) or (a.arity != a.args.length)
    return a

  slalfunc* tmp = a.func(a.args)
  return tmp
}

def slalfunc* I(slalfunc* x) {
  return x
}

def slalfunc* K(slalfunc* x, slalfunc* y) {
  return x
}

def slalfunc* S(slalfunc* x, slalfunc* y, slalfunc* z) {
  slalfunc* tmp1 = apply(x, z)
  slalfunc* tmp2 = apply(y, z)
  slalfunc* tmp3 = apply(tmp1, tmp2)
  return tmp3
}

[how is toString defined and called?]
def string toString(slalfunc* a) {
  return '(' + a.name + ' ' + a.args.map(:name).join(' ') + ')'
}

Value* Node::codegen(const Module &module, const IRBuilder<> &builder) {
  if (!isTerminal()) {
    vector<Value*> applyArgs;
    applyArgs.push_back(applicator->codegen(builder));
    applyArgs.push_back(input->codegen(builder));
    Function* apply = module.getFunction("apply");
    return builder.CreateCall(apply, applyArgs, "applyCall");
  }

  if [name is known] {
    Function* f = [look up function from name]
    int a = [arity of *f]
    return [create new slalfunc(f, name, a, vector<>())]
  }

  return [create new slalfunc(NULL, name, -1, vector<>())]
}